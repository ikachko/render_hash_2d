extern crate ocl;
extern crate image;
extern crate png;

use png::HasParameters;
use sha2::{Sha256, Digest};
use std::io;
use std::io::BufWriter;
use std::fmt;
use std::fs::{self, File};
use std::path::Path;

const IMAGE_SIZE_X: usize = 1920 * 2;
const IMAGE_SIZE_Y: usize = 1080 * 2;
const IMAGE_SIZE_BYTE: usize = IMAGE_SIZE_X * IMAGE_SIZE_Y * 4;

const TEX_SIZE_X: usize = 1920;
const TEX_SIZE_Y: usize = 1080;

const RECT_COUNT: usize = 6;
const TEX_COUNT: usize = 4;

enum FileReadError {
	IOError(io::Error),
	DecodeError(png::DecodingError),
}

impl From<io::Error> for FileReadError {
	fn from(e: io::Error) -> FileReadError {
		FileReadError::IOError(e)
	}
}

impl From<png::DecodingError> for FileReadError {
	fn from(e: png::DecodingError) -> FileReadError {
		FileReadError::DecodeError(e)
	}
}

struct Rect {
	x: usize,
	y: usize,
	w: usize,
	h: usize,
	t: usize
}

impl fmt::Display for Rect {
	fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
		write!(f, "x: {}, y: {}, w: {}, h: {}, t: {}",
					self.x, self.y, self.w, self.h, self.t)
	}
}

/// Function: read_files 
/// --------------------
/// @desc read all files from passed directory
/// @param &str dir - directory, from which textures will be readen
/// @param printable: bool - marker for printing(or not) message after finishing function 
/// @return Result<Vec<u8> FileReadError> - returns atlas of pictures or FileReadError with enum depending on error type
fn read_files(dir: &str, printable: bool) -> Result<Vec<u8>, FileReadError> {
	let paths = fs::read_dir(dir)?;
	let tex_size_bytes = TEX_SIZE_X * TEX_SIZE_Y * 4 * TEX_COUNT;
	let mut image_atlas = vec![0; tex_size_bytes];
	
	let mut tex_offset = 0;
	
	for path in paths {
		let decoder = png::Decoder::new(File::open(path?.path())?);
		let (info, mut reader) = decoder.read_info()?;
		let width = info.width as usize;
		let height = info.height as usize;
		let mut buff = vec![0; info.buffer_size()];

		let color_type = info.color_type;

		let num_bytes = {
			if color_type == png::ColorType::RGBA {
				4
			} else {3} 
		};
		
		reader.next_frame(&mut buff)?;
		
		for x in 0..TEX_SIZE_X {
			for y in 0..TEX_SIZE_Y {
				let src_offset = num_bytes * (x + y * width);
				let dst_offset = 4 * (x + y * TEX_SIZE_X) + tex_offset;

				image_atlas[dst_offset] = buff[src_offset];
				image_atlas[dst_offset + 1] = buff[src_offset + 1];
				image_atlas[dst_offset + 2] = buff[src_offset + 2];
				image_atlas[dst_offset + 3] = 255;
			}
		}
		tex_offset += width * height * num_bytes;
	}
	if printable {
		println!("Reading files from {} is finished.", &dir);	
	}
	Ok(image_atlas)
} 

/// Function: sha256_hash 
/// --------------------
/// @desc function for sha256 hash of u8 array
/// @param &[u8] data - message, that need to be hashed
/// @return [u8; 32] - returns 32 byte array
fn sha256_hash(data: &[u8]) -> [u8; 32] {
	let mut ret = [0; 32];
	let mut sha2 = Sha256::new();
	sha2.input(data);
	ret.copy_from_slice(sha2.result().as_slice());
	ret
}

/// Function: render_image
/// --------------------
/// @desc function for rendering image for hash with generated rectangles
/// @param rect_list: &[Rect] - array of generated rectangles
/// @param image_atlas: &Vec<u8> - atlas image from picked pictures
/// @param printable: bool - marker for printing(or not) message after finishing function 
/// @return Vec<u8> - returns u8 byte Vector with resulting image
fn render_image(rect_list: &[Rect], image_atlas: &Vec<u8>, printable: bool) -> Vec<u8> {
	let mut image_result: Vec<u8> = vec![0; IMAGE_SIZE_BYTE];

	for id in 0..(IMAGE_SIZE_X * IMAGE_SIZE_Y) {
		let x = id % IMAGE_SIZE_X;
		let y = (id as f64 / IMAGE_SIZE_X as f64).floor() as usize;
	
		let mut rect_id: isize = -1;

		let mut rect_x;
		let mut rect_y;
		let mut rect_w;
		let mut rect_h;

		for i in 0..rect_list.len() {
			rect_x = rect_list[i].x;
			rect_y = rect_list[i].y;
			rect_w = rect_list[i].w;
			rect_h = rect_list[i].h;

			let fit_x = x >= rect_x && (x < rect_x + rect_w);
			let fit_y = y >= rect_y && (y < rect_y + rect_h);

			rect_id = if (fit_x && fit_y) {i as isize} else {rect_id};
			if rect_id != -1 {break};
		}

		if (rect_id == -1) {
			image_result[4 * id] = 128;
			image_result[4 * id + 1] = 128;
			image_result[4 * id + 2] = 128;
			image_result[4 * id + 3] = 255;
			continue;
		}

		let rect_id = rect_id as usize;

		let rect_x = rect_list[rect_id].x;
		let rect_y = rect_list[rect_id].y;
		let rect_tex_idx = rect_list[rect_id].t;

		let tex_offset_x = (x - rect_x) % TEX_SIZE_X;
		let tex_offset_y = (y - rect_y) % TEX_SIZE_Y;
		let tex_offset = tex_offset_x + tex_offset_y * TEX_SIZE_X;
		let tex_offset = tex_offset + rect_tex_idx * TEX_SIZE_X * TEX_SIZE_Y;
		
		image_result[4 * id + 0] = image_atlas[4 * tex_offset + 0];
		image_result[4 * id + 1] = image_atlas[4 * tex_offset + 1];
		image_result[4 * id + 2] = image_atlas[4 * tex_offset + 2];
		image_result[4 * id + 3] = image_atlas[4 * tex_offset + 3];
	}
	if printable {
		println!("Render is finished.");
	}
	image_result
}

/// Function: generate_rectangles
/// --------------------
/// @desc function for creating rectangles using entropy from hashed message
/// @param msg: &[u8] - array of u8 ([0;255]) numbers 
/// @return Vec<Rect> - returns Vector of Rect filled with pseudo random rectangles
fn generate_rectangles(msg: &[u8]) -> Vec<Rect> {
	let scene_seed = sha256_hash(msg);

	let mut offset = 0;
	let mut rect_list: Vec<Rect> = Vec::new();

	let scale_x = (IMAGE_SIZE_X as f64 / 255.0).floor() as usize;
	let scale_y = (IMAGE_SIZE_Y as f64 / 255.0).floor() as usize;

	for i in 0..RECT_COUNT {
		let x = scene_seed[offset % scene_seed.len()] as usize * scale_x;
		offset += 1;
		let y = scene_seed[offset % scene_seed.len()] as usize * scale_y;
		offset += 1;
		let w = scene_seed[offset % scene_seed.len()] as usize * scale_x;
		offset += 1;
		let h = scene_seed[offset % scene_seed.len()] as usize * scale_y;
		offset += 1;
		let t = scene_seed[offset % scene_seed.len()] as usize % TEX_COUNT;

		rect_list.push(Rect {
			x,
			y,
			w,
			h,
			t
		})
	}
	rect_list
}

/// Function: dump_image
/// --------------------
/// @desc function for dumping array of colors to .png file
/// @param file_name: &str - name of file
/// @param image: &Vec<u8> - vector of numbers 
/// @param width: u32 - width of dumped image
/// @param height: u32 - height of dumped image
/// @return none
fn dump_image(file_name: &str, image: &Vec<u8>, width: u32, height: u32) {
	let path = Path::new(file_name);
	let file = File::create(path).unwrap();

	let ref mut w = BufWriter::new(file);

	let mut encoder = png::Encoder::new(w, width, height);
	encoder.set(png::ColorType::RGBA).set(png::BitDepth::Eight);

	let mut writer = encoder.write_header().unwrap();

	writer.write_image_data(&image).unwrap();
	println!("Image {} is dumped.", &file_name);
}

/// Function: render_hash_2d_cpu
/// --------------------
/// @desc public function for creating render hash
/// @param msg: &[u8] - message for entropy
/// @param &str dir - directory, from which textures will be readen
/// @param dump_img: bool - marker for dumping(or not) rendered image to .png file
/// @param printable: bool - marker for printing(or not) message after finishing function
/// @return [u8; 32] - generated hash
pub fn render_hash_2d_cpu(msg: &[u8], dir: &str, dump_img: bool, printable: bool) -> [u8; 32] {
	let image_atlas = match read_files(dir, printable) {
		Ok(texture) => texture,
		Err(e) => panic!(e)
	};
	let rect_list = generate_rectangles(&msg);
	let image = render_image(&rect_list, &image_atlas, printable);

	if dump_img {
		dump_image("./atlas_image.png", &image_atlas, IMAGE_SIZE_X as u32, IMAGE_SIZE_Y as u32 * TEX_COUNT as u32);
		dump_image("./render_result.png", &image, IMAGE_SIZE_X as u32, IMAGE_SIZE_Y as u32);
	}
	sha256_hash(&image)
}
