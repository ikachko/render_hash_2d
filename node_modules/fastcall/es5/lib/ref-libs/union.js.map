{"version":3,"sources":["../../../lib/ref-libs/union.js"],"names":["ref","require","assert","debug","module","exports","Union","UnionType","arg","data","store","Buffer","isBuffer","length","size","type","key","_instanceCreated","prototype","Object","create","proto","constructor","value","enumerable","writable","configurable","defineProperty","toString","fields","alignment","indirection","get","set","arguments","keys","forEach","name","buffer","offset","slice","union","isUnion","coerceType","equal","test","desc","field","cacheName","recalc","got","fieldNames","sizeof","pointer","alignof","Math","max","left","NULL"],"mappings":"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","file":"union.js","sourcesContent":["\n/**\n * Module dependencies.\n */\n\nvar ref = require('./ref')\nvar assert = require('assert')\nvar debug = require('debug')('ref-union')\n\n/**\n * Module exports.\n */\n\nmodule.exports = Union\n\n/**\n * The \"Union\" type constructor.\n */\n\nfunction Union () {\n  debug('defining new union \"type\"')\n\n  function UnionType (arg, data) {\n    if (!(this instanceof UnionType)) {\n      return new UnionType(arg, data)\n    }\n    debug('creating new union instance')\n    var store\n    if (Buffer.isBuffer(arg)) {\n      debug('using passed-in Buffer instance to back the union', arg)\n      assert(arg.length >= UnionType.size, 'Buffer instance must be at least '\n          + UnionType.size + ' bytes to back this untion type')\n      store = arg\n      arg = data\n    } else {\n      debug('creating new Buffer instance to back the union (size: %d)', UnionType.size)\n      store = new Buffer(UnionType.size)\n    }\n\n    // set the backing Buffer store\n    store.type = UnionType\n    this['ref.buffer'] = store\n\n    // initialise the union with values supplied\n    if (arg) {\n      //TODO: Sanity check - e.g. (Object.keys(arg).length == 1)\n      for (var key in arg) {\n        // hopefully hit the union setters\n        this[key] = arg[key]\n      }\n    }\n    UnionType._instanceCreated = true\n  }\n\n  // make instances inherit from `proto`\n  UnionType.prototype = Object.create(proto, {\n    constructor: {\n        value: UnionType\n      , enumerable: false\n      , writable: true\n      , configurable: true\n    }\n  })\n\n  UnionType.defineProperty = defineProperty\n  UnionType.toString = toString\n  UnionType.fields = {}\n\n  // comply with ref's \"type\" interface\n  UnionType.size = 0\n  UnionType.alignment = 0\n  UnionType.indirection = 1\n  UnionType.get = get\n  UnionType.set = set\n\n  // Read the fields list\n  var arg = arguments[0]\n  if (typeof arg === 'object') {\n    Object.keys(arg).forEach(function (name) {\n      var type = arg[name];\n      UnionType.defineProperty(name, type);\n    })\n  }\n\n  return UnionType\n}\n\nfunction get (buffer, offset) {\n  debug('Union \"type\" getter for buffer at offset', buffer, offset)\n  if (offset > 0) {\n    buffer = buffer.slice(offset)\n  }\n  return new this(buffer)\n}\n\nfunction set (buffer, offset, value) {\n  debug('Union \"type\" setter for buffer at offset', buffer, offset, value)\n  if (offset > 0) {\n    buffer = buffer.slice(offset)\n  }\n  var union = new this(buffer)\n  var isUnion = value instanceof this\n  if (isUnion) {\n    // TODO: optimize - use Buffer#copy()\n    Object.keys(this.fields).forEach(function (name) {\n      // hopefully hit the setters\n      union[name] = value[name]\n    })\n  } else {\n    for (var name in value) {\n      // hopefully hit the setters\n      union[name] = value[name]\n    }\n  }\n}\n\nfunction toString () {\n  return '[UnionType]'\n}\n\n/**\n * Adds a new field to the union instance with the given name and type.\n * Note that this function will throw an Error if any instances of the union\n * type have already been created, therefore this function must be called at the\n * beginning, before any instances are created.\n */\n\nfunction defineProperty (name, type) {\n  debug('defining new union type field', name)\n\n  // allow string types for convenience\n  type = ref.coerceType(type)\n\n  assert(!this._instanceCreated, 'an instance of this Union type has already '\n      + 'been created, cannot add new data members anymore')\n  assert.equal('string', typeof name, 'expected a \"string\" field name')\n  assert(type && /object|function/i.test(typeof type) && 'size' in type &&\n      'indirection' in type\n      , 'expected a \"type\" object describing the field type: \"' + type + '\"')\n  assert(!(name in this.prototype), 'the field \"' + name\n      + '\" already exists in this Union type')\n\n  // define the getter/setter property\n  var desc = {\n      enumerable: true\n    , configurable: true\n    , get: get\n    , set: set\n  };\n  Object.defineProperty(this.prototype, name, desc);\n\n  var field = {\n    type: type\n  }\n  this.fields[name] = field\n  var cacheName = '_cache' + name\n\n  // calculate the new size and alignment\n  recalc(this);\n\n  function get () {\n    if (this[cacheName]) {\n      return this[cacheName]\n    }\n    debug('getting \"%s\" union field (length: %d)', name, type.size)\n    var got = ref.get(this['ref.buffer'], 0, type)\n    if (typeof got === 'object') {\n      this[cacheName] = got;\n    }\n    return got;\n  }\n\n  function set (value) {\n    this[cacheName] = null\n    debug('setting \"%s\" union field (length: %d)', name, type.size, value)\n    return ref.set(this['ref.buffer'], 0, value, type)\n  }\n}\n\nfunction recalc (union) {\n  // reset size and alignment\n  union.size = 0\n  union.alignment = 0\n\n  var fieldNames = Object.keys(union.fields)\n\n  // loop through to set the size of the union of the largest member field\n  // and the alignment to the requirements of the largest member\n  fieldNames.forEach(function (name) {\n    var field = union.fields[name]\n    var type = field.type\n\n    var size = type.indirection === 1 ? type.size : ref.sizeof.pointer\n    var alignment = type.alignment || ref.alignof.pointer\n    if (type.indirection > 1) {\n      alignment = ref.alignof.pointer\n    }\n    union.alignment = Math.max(union.alignment, alignment)\n    union.size = Math.max(union.size, size)\n  })\n\n  // any padding\n  var left = union.size % union.alignment\n  if (left > 0) {\n    debug('additional padding to the end of union:', union.alignment - left)\n    union.size += union.alignment - left\n  }\n}\n\n\n\n/**\n * the base prototype that union type instances will inherit from.\n */\n\nvar proto = {}\n\nproto['ref.buffer'] = ref.NULL\n\n/**\n * returns a Buffer pointing to this union data structure.\n */\n\nproto.ref = function ref () {\n  return this['ref.buffer']\n}\n"]}