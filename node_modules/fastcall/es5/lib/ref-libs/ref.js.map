{"version":3,"sources":["../../../lib/ref-libs/ref.js"],"names":["assert","require","debug","exports","module","refType","type","_type","coerceType","rtn","Object","create","indirection","name","derefType","Error","getPrototypeOf","types","replace","toLowerCase","void","CString","refCount","TypeError","JSON","stringify","i","getType","buffer","size","length","get","set","offset","sizeof","pointer","reference","readPointer","value","writePointer","alloc","Buffer","arguments","allocCString","string","encoding","isBuffer","isNull","NULL","byteLength","writeCString","charPtrType","equal","len","write","writeUInt8","endianness","readInt64","readUInt64","writeInt64","writeUInt64","opposite","int64temp","int64","uint64temp","uint64","ref","deref","_attach","buf","obj","_refs","push","_writeObject","writeObject","persistent","_writePointer","ptr","_reinterpret","reinterpret","_reinterpretUntilZeros","reinterpretUntilZeros","val","int8","readInt8","charCodeAt","writeInt8","uint8","readUInt8","int16","uint16","int32","uint32","float","double","readObject","alignment","alignof","_buf","readCString","utfstringwarned","defineProperty","enumerable","configurable","console","error","forEach","unsigned","typeName","keys","bool","_get","_set","char","NULL_POINTER","prototype","address","hexAddress","readInt64BE","writeInt64BE","readUInt64BE","writeUInt64BE","readInt64LE","writeInt64LE","readUInt64LE","writeUInt64LE","inspect","overwriteInspect","SlowBuffer","refinspect","v","apply"],"mappings":"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","file":"ref.js","sourcesContent":["\nvar assert = require('assert')\nvar debug = require('debug')('ref')\n\nexports = module.exports = require('bindings')('ref')\n\n/**\n * A `Buffer` that references the C NULL pointer. That is, its memory address\n * points to 0. Its `length` is 0 because accessing any data from this buffer\n * would cause a _segmentation fault_.\n *\n * ```\n * console.log(ref.NULL);\n * <SlowBuffer@0x0 >\n * ```\n *\n * @name NULL\n * @type Buffer\n */\n\n/**\n * A string that represents the native endianness of the machine's processor.\n * The possible values are either `\"LE\"` or `\"BE\"`.\n *\n * ```\n * console.log(ref.endianness);\n * 'LE'\n * ```\n *\n * @name endianness\n * @type String\n */\n\n/**\n * Accepts a `Buffer` instance and returns the memory address of the buffer\n * instance.\n *\n * ```\n * console.log(ref.address(new Buffer(1)));\n * 4320233616\n *\n * console.log(ref.address(ref.NULL)));\n * 0\n * ```\n *\n * @param {Buffer} buffer The buffer to get the memory address of.\n * @return {Number} The memory address the buffer instance.\n * @name address\n * @type method\n */\n\n/**\n * Accepts a `Buffer` instance and returns _true_ if the buffer represents the\n * NULL pointer, _false_ otherwise.\n *\n * ```\n * console.log(ref.isNull(new Buffer(1)));\n * false\n *\n * console.log(ref.isNull(ref.NULL));\n * true\n * ```\n *\n * @param {Buffer} buffer The buffer to check for NULL.\n * @return {Boolean} true or false.\n * @name isNull\n * @type method\n */\n\n/**\n * Reads a JavaScript Object that has previously been written to the given\n * _buffer_ at the given _offset_.\n *\n * ```\n * var obj = { foo: 'bar' };\n * var buf = ref.alloc('Object', obj);\n *\n * var obj2 = ref.readObject(buf, 0);\n * console.log(obj === obj2);\n * true\n * ```\n *\n * @param {Buffer} buffer The buffer to read an Object from.\n * @param {Number} offset The offset to begin reading from.\n * @return {Object} The Object that was read from _buffer_.\n * @name readObject\n * @type method\n */\n\n/**\n * Reads a Buffer instance from the given _buffer_ at the given _offset_.\n * The _size_ parameter specifies the `length` of the returned Buffer instance,\n * which defaults to __0__.\n *\n * ```\n * var buf = new Buffer('hello world');\n * var pointer = ref.alloc('pointer');\n *\n * var buf2 = ref.readPointer(pointer, 0, buf.length);\n * console.log(buf.toString());\n * 'hello world'\n * ```\n *\n * @param {Buffer} buffer The buffer to read a Buffer from.\n * @param {Number} offset The offset to begin reading from.\n * @param {Number} length (optional) The length of the returned Buffer. Defaults to 0.\n * @return {Buffer} The Buffer instance that was read from _buffer_.\n * @name readPointer\n * @type method\n */\n\n/**\n * Returns a JavaScript String read from _buffer_ at the given _offset_. The\n * C String is read until the first NULL byte, which indicates the end of the\n * String.\n *\n * This function can read beyond the `length` of a Buffer.\n *\n * ```\n * var buf = new Buffer('hello\\0world\\0');\n *\n * var str = ref.readCString(buf, 0);\n * console.log(str);\n * 'hello'\n * ```\n *\n * @param {Buffer} buffer The buffer to read a Buffer from.\n * @param {Number} offset The offset to begin reading from.\n * @return {String} The String that was read from _buffer_.\n * @name readCString\n * @type method\n */\n\n/**\n * Returns a big-endian signed 64-bit int read from _buffer_ at the given\n * _offset_.\n *\n * If the returned value will fit inside a JavaScript Number without losing\n * precision, then a Number is returned, otherwise a String is returned.\n *\n * ```\n * var buf = ref.alloc('int64');\n * ref.writeInt64BE(buf, 0, '9223372036854775807');\n *\n * var val = ref.readInt64BE(buf, 0)\n * console.log(val)\n * '9223372036854775807'\n * ```\n *\n * @param {Buffer} buffer The buffer to read a Buffer from.\n * @param {Number} offset The offset to begin reading from.\n * @return {Number|String} The Number or String that was read from _buffer_.\n * @name readInt64BE\n * @type method\n */\n\n/**\n * Returns a little-endian signed 64-bit int read from _buffer_ at the given\n * _offset_.\n *\n * If the returned value will fit inside a JavaScript Number without losing\n * precision, then a Number is returned, otherwise a String is returned.\n *\n * ```\n * var buf = ref.alloc('int64');\n * ref.writeInt64LE(buf, 0, '9223372036854775807');\n *\n * var val = ref.readInt64LE(buf, 0)\n * console.log(val)\n * '9223372036854775807'\n * ```\n *\n * @param {Buffer} buffer The buffer to read a Buffer from.\n * @param {Number} offset The offset to begin reading from.\n * @return {Number|String} The Number or String that was read from _buffer_.\n * @name readInt64LE\n * @type method\n */\n\n/**\n * Returns a big-endian unsigned 64-bit int read from _buffer_ at the given\n * _offset_.\n *\n * If the returned value will fit inside a JavaScript Number without losing\n * precision, then a Number is returned, otherwise a String is returned.\n *\n * ```\n * var buf = ref.alloc('uint64');\n * ref.writeUInt64BE(buf, 0, '18446744073709551615');\n *\n * var val = ref.readUInt64BE(buf, 0)\n * console.log(val)\n * '18446744073709551615'\n * ```\n *\n * @param {Buffer} buffer The buffer to read a Buffer from.\n * @param {Number} offset The offset to begin reading from.\n * @return {Number|String} The Number or String that was read from _buffer_.\n * @name readUInt64BE\n * @type method\n */\n\n/**\n * Returns a little-endian unsigned 64-bit int read from _buffer_ at the given\n * _offset_.\n *\n * If the returned value will fit inside a JavaScript Number without losing\n * precision, then a Number is returned, otherwise a String is returned.\n *\n * ```\n * var buf = ref.alloc('uint64');\n * ref.writeUInt64LE(buf, 0, '18446744073709551615');\n *\n * var val = ref.readUInt64LE(buf, 0)\n * console.log(val)\n * '18446744073709551615'\n * ```\n *\n * @param {Buffer} buffer The buffer to read a Buffer from.\n * @param {Number} offset The offset to begin reading from.\n * @return {Number|String} The Number or String that was read from _buffer_.\n * @name readUInt64LE\n * @type method\n */\n\n/**\n * Writes the _input_ Number or String as a big-endian signed 64-bit int into\n * _buffer_ at the given _offset_.\n *\n * ```\n * var buf = ref.alloc('int64');\n * ref.writeInt64BE(buf, 0, '9223372036854775807');\n * ```\n *\n * @param {Buffer} buffer The buffer to write to.\n * @param {Number} offset The offset to begin writing from.\n * @param {Number|String} input This String or Number which gets written.\n * @name writeInt64BE\n * @type method\n */\n\n/**\n * Writes the _input_ Number or String as a little-endian signed 64-bit int into\n * _buffer_ at the given _offset_.\n *\n * ```\n * var buf = ref.alloc('int64');\n * ref.writeInt64LE(buf, 0, '9223372036854775807');\n * ```\n *\n * @param {Buffer} buffer The buffer to write to.\n * @param {Number} offset The offset to begin writing from.\n * @param {Number|String} input This String or Number which gets written.\n * @name writeInt64LE\n * @type method\n */\n\n/**\n * Writes the _input_ Number or String as a big-endian unsigned 64-bit int into\n * _buffer_ at the given _offset_.\n *\n * ```\n * var buf = ref.alloc('uint64');\n * ref.writeUInt64BE(buf, 0, '18446744073709551615');\n * ```\n *\n * @param {Buffer} buffer The buffer to write to.\n * @param {Number} offset The offset to begin writing from.\n * @param {Number|String} input This String or Number which gets written.\n * @name writeUInt64BE\n * @type method\n */\n\n/**\n * Writes the _input_ Number or String as a little-endian unsigned 64-bit int\n * into _buffer_ at the given _offset_.\n *\n * ```\n * var buf = ref.alloc('uint64');\n * ref.writeUInt64LE(buf, 0, '18446744073709551615');\n * ```\n *\n * @param {Buffer} buffer The buffer to write to.\n * @param {Number} offset The offset to begin writing from.\n * @param {Number|String} input This String or Number which gets written.\n * @name writeUInt64LE\n * @type method\n */\n\n/**\n * Returns a new clone of the given \"type\" object, with its\n * `indirection` level incremented by **1**.\n *\n * Say you wanted to create a type representing a `void *`:\n *\n * ```\n * var voidPtrType = ref.refType(ref.types.void);\n * ```\n *\n * @param {Object|String} type The \"type\" object to create a reference type from. Strings get coerced first.\n * @return {Object} The new \"type\" object with its `indirection` incremented by 1.\n */\n\nexports.refType = function refType (type) {\n  var _type = exports.coerceType(type)\n  var rtn = Object.create(_type)\n  rtn.indirection++\n  if (_type.name) {\n    rtn.name = _type.name + '*'\n  }\n  return rtn\n}\n\n/**\n * Returns a new clone of the given \"type\" object, with its\n * `indirection` level decremented by 1.\n *\n * @param {Object|String} type The \"type\" object to create a dereference type from. Strings get coerced first.\n * @return {Object} The new \"type\" object with its `indirection` decremented by 1.\n */\n\nexports.derefType = function derefType (type) {\n  var _type = exports.coerceType(type)\n  if (_type.indirection === 1) {\n    throw new Error('Cannot create deref\\'d type for type with indirection 1')\n  }\n  var rtn = Object.getPrototypeOf(_type)\n  if (rtn.indirection !== _type.indirection - 1) {\n    // slow case\n    rtn = Object.create(_type)\n    rtn.indirection--\n  }\n  return rtn\n}\n\n/**\n * Coerces a \"type\" object from a String or an actual \"type\" object. String values\n * are looked up from the `ref.types` Object. So:\n *\n *   * `\"int\"` gets coerced into `ref.types.int`.\n *   * `\"int *\"` gets translated into `ref.refType(ref.types.int)`\n *   * `ref.types.int` gets translated into `ref.types.int` (returns itself)\n *\n * Throws an Error if no valid \"type\" object could be determined. Most `ref`\n * functions use this function under the hood, so anywhere a \"type\" object is\n * expected, a String may be passed as well, including simply setting the\n * `buffer.type` property.\n *\n * ```\n * var type = ref.coerceType('int **');\n *\n * console.log(type.indirection);\n * 3\n * ```\n *\n * @param {Object|String} type The \"type\" Object or String to coerce.\n * @return {Object} A \"type\" object\n */\n\nexports.coerceType = function coerceType (type) {\n  var rtn = type\n  if (typeof rtn === 'string') {\n    rtn = exports.types[type]\n    if (rtn) return rtn\n\n    // strip whitespace\n    rtn = type.replace(/\\s+/g, '').toLowerCase()\n    if (rtn === 'pointer') {\n      // legacy \"pointer\" being used :(\n      rtn = exports.refType(exports.types.void) // void *\n    } else if (rtn === 'string') {\n      rtn = exports.types.CString // special char * type\n    } else {\n      var refCount = 0\n      rtn = rtn.replace(/\\*/g, function () {\n        refCount++\n        return ''\n      })\n      // allow string names to be passed in\n      rtn = exports.types[rtn]\n      if (refCount > 0) {\n        if (!(rtn && 'size' in rtn && 'indirection' in rtn)) {\n          throw new TypeError('could not determine a proper \"type\" from: ' + JSON.stringify(type))\n        }\n        for (var i = 0; i < refCount; i++) {\n          rtn = exports.refType(rtn)\n        }\n      }\n    }\n  }\n  if (!(rtn && 'size' in rtn && 'indirection' in rtn)) {\n    throw new TypeError('could not determine a proper \"type\" from: ' + JSON.stringify(type))\n  }\n  return rtn\n}\n\n/**\n * Returns the \"type\" property of the given Buffer.\n * Creates a default type for the buffer when none exists.\n *\n * @param {Buffer} buffer The Buffer instance to get the \"type\" object from.\n * @return {Object} The \"type\" object from the given Buffer.\n */\n\nexports.getType = function getType (buffer) {\n  if (!buffer.type) {\n    debug('WARN: no \"type\" found on buffer, setting default \"type\"', buffer)\n    buffer.type = {}\n    buffer.type.size = buffer.length\n    buffer.type.indirection = 1\n    buffer.type.get = function get () {\n      throw new Error('unknown \"type\"; cannot get()')\n    }\n    buffer.type.set = function set () {\n      throw new Error('unknown \"type\"; cannot set()')\n    }\n  }\n  return exports.coerceType(buffer.type)\n}\n\n/**\n * Calls the `get()` function of the Buffer's current \"type\" (or the\n * passed in _type_ if present) at the given _offset_.\n *\n * This function handles checking the \"indirection\" level and returning a\n * proper \"dereferenced\" Bufffer instance when necessary.\n *\n * @param {Buffer} buffer The Buffer instance to read from.\n * @param {Number} offset (optional) The offset on the Buffer to start reading from. Defaults to 0.\n * @param {Object|String} type (optional) The \"type\" object to use when reading. Defaults to calling `getType()` on the buffer.\n * @return {?} Whatever value the \"type\" used when reading returns.\n */\n\nexports.get = function get (buffer, offset, type) {\n  if (!offset) {\n    offset = 0\n  }\n  if (type) {\n    type = exports.coerceType(type)\n  } else {\n    type = exports.getType(buffer)\n  }\n  debug('get(): (offset: %d)', offset, buffer)\n  assert(type.indirection > 0, '\"indirection\" level must be at least 1')\n  if (type.indirection === 1) {\n    // need to check \"type\"\n    return type.get(buffer, offset)\n  } else {\n    // need to create a deref'd Buffer\n    var size = type.indirection === 2 ? type.size : exports.sizeof.pointer\n    var reference = exports.readPointer(buffer, offset, size)\n    reference.type = exports.derefType(type)\n    return reference\n  }\n}\n\n/**\n * Calls the `set()` function of the Buffer's current \"type\" (or the\n * passed in _type_ if present) at the given _offset_.\n *\n * This function handles checking the \"indirection\" level writing a pointer rather\n * than calling the `set()` function if the indirection is greater than 1.\n *\n * @param {Buffer} buffer The Buffer instance to write to.\n * @param {Number} offset The offset on the Buffer to start writing to.\n * @param {?} value The value to write to the Buffer instance.\n * @param {Object|String} type (optional) The \"type\" object to use when reading. Defaults to calling `getType()` on the buffer.\n */\n\nexports.set = function set (buffer, offset, value, type) {\n  if (!offset) {\n    offset = 0\n  }\n  if (type) {\n    type = exports.coerceType(type)\n  } else {\n    type = exports.getType(buffer)\n  }\n  debug('set(): (offset: %d)', offset, buffer, value)\n  assert(type.indirection >= 1, '\"indirection\" level must be at least 1')\n  if (type.indirection === 1) {\n    type.set(buffer, offset, value)\n  } else {\n    exports.writePointer(buffer, offset, value)\n  }\n}\n\n\n/**\n * Returns a new Buffer instance big enough to hold `type`,\n * with the given `value` written to it.\n *\n * ``` js\n * var intBuf = ref.alloc(ref.types.int)\n * var int_with_4 = ref.alloc(ref.types.int, 4)\n * ```\n *\n * @param {Object|String} type The \"type\" object to allocate. Strings get coerced first.\n * @param {?} value (optional) The initial value set on the returned Buffer, using _type_'s `set()` function.\n * @return {Buffer} A new Buffer instance with it's `type` set to \"type\", and (optionally) \"value\" written to it.\n */\n\nexports.alloc = function alloc (_type, value) {\n  var type = exports.coerceType(_type)\n  debug('allocating Buffer for type with \"size\"', type.size)\n  var size\n  if (type.indirection === 1) {\n    size = type.size\n  } else {\n    size = exports.sizeof.pointer\n  }\n  var buffer = new Buffer(size)\n  buffer.type = type\n  if (arguments.length >= 2) {\n    debug('setting value on allocated buffer', value)\n    exports.set(buffer, 0, value, type)\n  }\n  return buffer\n}\n\n/**\n * Returns a new `Buffer` instance with the given String written to it with the\n * given encoding (defaults to __'utf8'__). The buffer is 1 byte longer than the\n * string itself, and is NUL terminated.\n *\n * ```\n * var buf = ref.allocCString('hello world');\n *\n * console.log(buf.toString());\n * 'hello world\\u0000'\n * ```\n *\n * @param {String} string The JavaScript string to be converted to a C string.\n * @param {String} encoding (optional) The encoding to use for the C string. Defaults to __'utf8'__.\n * @return {Buffer} The new `Buffer` instance with the specified String wrtten to it, and a trailing NUL byte.\n */\n\nexports.allocCString = function allocCString (string, encoding) {\n  if (null == string || (Buffer.isBuffer(string) && exports.isNull(string))) {\n    return exports.NULL\n  }\n  var size = Buffer.byteLength(string, encoding) + 1\n  var buffer = new Buffer(size)\n  exports.writeCString(buffer, 0, string, encoding)\n  buffer.type = charPtrType\n  return buffer\n}\n\n/**\n * Writes the given string as a C String (NULL terminated) to the given buffer\n * at the given offset. \"encoding\" is optional and defaults to __'utf8'__.\n *\n * Unlike `readCString()`, this function requires the buffer to actually have the\n * proper length.\n *\n * @param {Buffer} buffer The Buffer instance to write to.\n * @param {Number} offset The offset of the buffer to begin writing at.\n * @param {String} string The JavaScript String to write that will be written to the buffer.\n * @param {String} encoding (optional) The encoding to read the C string as. Defaults to __'utf8'__.\n */\n\nexports.writeCString = function writeCString (buffer, offset, string, encoding) {\n  assert(Buffer.isBuffer(buffer), 'expected a Buffer as the first argument')\n  assert.equal('string', typeof string, 'expected a \"string\" as the third argument')\n  if (!offset) {\n    offset = 0\n  }\n  if (!encoding) {\n    encoding = 'utf8'\n  }\n  var size = buffer.length - offset\n  var len = buffer.write(string, offset, size, encoding)\n  buffer.writeUInt8(0, offset + len)  // NUL terminate\n}\n\nexports['readInt64' + exports.endianness] = exports.readInt64\nexports['readUInt64' + exports.endianness] = exports.readUInt64\nexports['writeInt64' + exports.endianness] = exports.writeInt64\nexports['writeUInt64' + exports.endianness] = exports.writeUInt64\n\nvar opposite = exports.endianness == 'LE' ? 'BE' : 'LE'\nvar int64temp = new Buffer(exports.sizeof.int64)\nvar uint64temp = new Buffer(exports.sizeof.uint64)\n\nexports['readInt64' + opposite] = function (buffer, offset) {\n  for (var i = 0; i < exports.sizeof.int64; i++) {\n    int64temp[i] = buffer[offset + exports.sizeof.int64 - i - 1]\n  }\n  return exports.readInt64(int64temp, 0)\n}\nexports['readUInt64' + opposite] = function (buffer, offset) {\n  for (var i = 0; i < exports.sizeof.uint64; i++) {\n    uint64temp[i] = buffer[offset + exports.sizeof.uint64 - i - 1]\n  }\n  return exports.readUInt64(uint64temp, 0)\n}\nexports['writeInt64' + opposite] = function (buffer, offset, value) {\n  exports.writeInt64(int64temp, 0, value)\n  for (var i = 0; i < exports.sizeof.int64; i++) {\n    buffer[offset + i] = int64temp[exports.sizeof.int64 - i - 1]\n  }\n}\nexports['writeUInt64' + opposite] = function (buffer, offset, value) {\n  exports.writeUInt64(uint64temp, 0, value)\n  for (var i = 0; i < exports.sizeof.uint64; i++) {\n    buffer[offset + i] = uint64temp[exports.sizeof.uint64 - i - 1]\n  }\n}\n\n/**\n * `ref()` accepts a Buffer instance and returns a new Buffer\n * instance that is \"pointer\" sized and has its data pointing to the given\n * Buffer instance. Essentially the created Buffer is a \"reference\" to the\n * original pointer, equivalent to the following C code:\n *\n * ``` c\n * char *buf = buffer;\n * char **ref = &buf;\n * ```\n *\n * @param {Buffer} buffer A Buffer instance to create a reference to.\n * @return {Buffer} A new Buffer instance pointing to _buffer_.\n */\n\nexports.ref = function ref (buffer) {\n  debug('creating a reference to buffer', buffer)\n  var type = exports.refType(exports.getType(buffer))\n  return exports.alloc(type, buffer)\n}\n\n/**\n * Accepts a Buffer instance and attempts to \"dereference\" it.\n * That is, first it checks the `indirection` count of _buffer_'s \"type\", and if\n * it's greater than __1__ then it merely returns another Buffer, but with one\n * level less `indirection`.\n *\n * When _buffer_'s indirection is at __1__, then it checks for `buffer.type`\n * which should be an Object with its own `get()` function.\n *\n * ```\n * var buf = ref.alloc('int', 6);\n *\n * var val = ref.deref(buf);\n * console.log(val);\n * 6\n * ```\n *\n *\n * @param {Buffer} buffer A Buffer instance to dereference.\n * @return {?} The returned value after dereferencing _buffer_.\n */\n\nexports.deref = function deref (buffer) {\n  debug('dereferencing buffer', buffer)\n  return exports.get(buffer)\n}\n\n/**\n * Attaches _object_ to _buffer_ such that it prevents _object_ from being garbage\n * collected until _buffer_ does.\n *\n * @param {Buffer} buffer A Buffer instance to attach _object_ to.\n * @param {Object|Buffer} object An Object or Buffer to prevent from being garbage collected until _buffer_ does.\n * @api private\n */\n\nexports._attach = function _attach (buf, obj) {\n  if (!buf._refs) {\n    buf._refs = []\n  }\n  buf._refs.push(obj)\n}\n\n/**\n * Same as `ref.writeObject()`, except that this version does not _attach_ the\n * Object to the Buffer, which is potentially unsafe if the garbage collector\n * runs.\n *\n * @param {Buffer} buffer A Buffer instance to write _object_ to.\n * @param {Number} offset The offset on the Buffer to start writing at.\n * @param {Object} object The Object to be written into _buffer_.\n * @api private\n */\n\nexports._writeObject = exports.writeObject\n\n/**\n * Writes a pointer to _object_ into _buffer_ at the specified _offset.\n *\n * This function \"attaches\" _object_ to _buffer_ to prevent it from being garbage\n * collected.\n *\n * ```\n * var buf = ref.alloc('Object');\n * ref.writeObject(buf, 0, { foo: 'bar' });\n *\n * ```\n *\n * @param {Buffer} buffer A Buffer instance to write _object_ to.\n * @param {Number} offset The offset on the Buffer to start writing at.\n * @param {Object} object The Object to be written into _buffer_.\n */\n\nexports.writeObject = function writeObject (buf, offset, obj, persistent) {\n  debug('writing Object to buffer', buf, offset, obj, persistent)\n  exports._writeObject(buf, offset, obj, persistent)\n  exports._attach(buf, obj)\n}\n\n/**\n * Same as `ref.writePointer()`, except that this version does not attach\n * _pointer_ to _buffer_, which is potentially unsafe if the garbage collector\n * runs.\n *\n * @param {Buffer} buffer A Buffer instance to write _pointer to.\n * @param {Number} offset The offset on the Buffer to start writing at.\n * @param {Buffer} pointer The Buffer instance whose memory address will be written to _buffer_.\n * @api private\n */\n\nexports._writePointer = exports.writePointer\n\n/**\n * Writes the memory address of _pointer_ to _buffer_ at the specified _offset_.\n *\n * This function \"attaches\" _object_ to _buffer_ to prevent it from being garbage\n * collected.\n *\n * ```\n * var someBuffer = new Buffer('whatever');\n * var buf = ref.alloc('pointer');\n * ref.writePointer(buf, 0, someBuffer);\n * ```\n *\n * @param {Buffer} buffer A Buffer instance to write _pointer to.\n * @param {Number} offset The offset on the Buffer to start writing at.\n * @param {Buffer} pointer The Buffer instance whose memory address will be written to _buffer_.\n */\n\nexports.writePointer = function writePointer (buf, offset, ptr) {\n  debug('writing pointer to buffer', buf, offset, ptr)\n  exports._writePointer(buf, offset, ptr)\n  exports._attach(buf, ptr)\n}\n\n/**\n * Same as `ref.reinterpret()`, except that this version does not attach\n * _buffer_ to the returned Buffer, which is potentially unsafe if the\n * garbage collector runs.\n *\n * @param {Buffer} buffer A Buffer instance to base the returned Buffer off of.\n * @param {Number} size The `length` property of the returned Buffer.\n * @param {Number} offset The offset of the Buffer to begin from.\n * @return {Buffer} A new Buffer instance with the same memory address as _buffer_, and the requested _size_.\n * @api private\n */\n\nexports._reinterpret = exports.reinterpret\n\n/**\n * Returns a new Buffer instance with the specified _size_, with the same memory\n * address as _buffer_.\n *\n * This function \"attaches\" _buffer_ to the returned Buffer to prevent it from\n * being garbage collected.\n *\n * @param {Buffer} buffer A Buffer instance to base the returned Buffer off of.\n * @param {Number} size The `length` property of the returned Buffer.\n * @param {Number} offset The offset of the Buffer to begin from.\n * @return {Buffer} A new Buffer instance with the same memory address as _buffer_, and the requested _size_.\n */\n\nexports.reinterpret = function reinterpret (buffer, size, offset) {\n  debug('reinterpreting buffer to \"%d\" bytes', size)\n  var rtn = exports._reinterpret(buffer, size, offset || 0)\n  exports._attach(rtn, buffer)\n  return rtn\n}\n\n/**\n * Same as `ref.reinterpretUntilZeros()`, except that this version does not\n * attach _buffer_ to the returned Buffer, which is potentially unsafe if the\n * garbage collector runs.\n *\n * @param {Buffer} buffer A Buffer instance to base the returned Buffer off of.\n * @param {Number} size The number of sequential, aligned `NULL` bytes that are required to terminate the buffer.\n * @param {Number} offset The offset of the Buffer to begin from.\n * @return {Buffer} A new Buffer instance with the same memory address as _buffer_, and a variable `length` that is terminated by _size_ NUL bytes.\n * @api private\n */\n\nexports._reinterpretUntilZeros = exports.reinterpretUntilZeros\n\n/**\n * Accepts a `Buffer` instance and a number of `NULL` bytes to read from the\n * pointer. This function will scan past the boundary of the Buffer's `length`\n * until it finds `size` number of aligned `NULL` bytes.\n *\n * This is useful for finding the end of NUL-termintated array or C string. For\n * example, the `readCString()` function _could_ be implemented like:\n *\n * ```\n * function readCString (buf) {\n *   return ref.reinterpretUntilZeros(buf, 1).toString('utf8')\n * }\n * ```\n *\n * This function \"attaches\" _buffer_ to the returned Buffer to prevent it from\n * being garbage collected.\n *\n * @param {Buffer} buffer A Buffer instance to base the returned Buffer off of.\n * @param {Number} size The number of sequential, aligned `NULL` bytes are required to terminate the buffer.\n * @param {Number} offset The offset of the Buffer to begin from.\n * @return {Buffer} A new Buffer instance with the same memory address as _buffer_, and a variable `length` that is terminated by _size_ NUL bytes.\n */\n\nexports.reinterpretUntilZeros = function reinterpretUntilZeros (buffer, size, offset) {\n  debug('reinterpreting buffer to until \"%d\" NULL (0) bytes are found', size)\n  var rtn = exports._reinterpretUntilZeros(buffer, size, offset || 0)\n  exports._attach(rtn, buffer)\n  return rtn\n}\n\n\n// the built-in \"types\"\nvar types = exports.types = {}\n\n/**\n * The `void` type.\n *\n * @section types\n */\n\ntypes.void = {\n    size: 0\n  , indirection: 1\n  , get: function get (buf, offset) {\n      debug('getting `void` type (returns `null`)')\n      return null\n    }\n  , set: function set (buf, offset, val) {\n      debug('setting `void` type (no-op)')\n    }\n}\n\n/**\n * The `int8` type.\n */\n\ntypes.int8 = {\n    size: exports.sizeof.int8\n  , indirection: 1\n  , get: function get (buf, offset) {\n      return buf.readInt8(offset || 0)\n    }\n  , set: function set (buf, offset, val) {\n      if (typeof val === 'string') {\n        val = val.charCodeAt(0)\n      }\n      return buf.writeInt8(val, offset || 0)\n    }\n}\n\n/**\n * The `uint8` type.\n */\n\ntypes.uint8 = {\n    size: exports.sizeof.uint8\n  , indirection: 1\n  , get: function get (buf, offset) {\n      return buf.readUInt8(offset || 0)\n    }\n  , set: function set (buf, offset, val) {\n      if (typeof val === 'string') {\n        val = val.charCodeAt(0)\n      }\n      return buf.writeUInt8(val, offset || 0)\n    }\n}\n\n/**\n * The `int16` type.\n */\n\ntypes.int16 = {\n    size: exports.sizeof.int16\n  , indirection: 1\n  , get: function get (buf, offset) {\n      return buf['readInt16' + exports.endianness](offset || 0)\n    }\n  , set: function set (buf, offset, val) {\n      return buf['writeInt16' + exports.endianness](val, offset || 0)\n    }\n}\n\n/**\n * The `uint16` type.\n */\n\ntypes.uint16 = {\n    size: exports.sizeof.uint16\n  , indirection: 1\n  , get: function get (buf, offset) {\n      return buf['readUInt16' + exports.endianness](offset || 0)\n    }\n  , set: function set (buf, offset, val) {\n      return buf['writeUInt16' + exports.endianness](val, offset || 0)\n    }\n}\n\n/**\n * The `int32` type.\n */\n\ntypes.int32 = {\n    size: exports.sizeof.int32\n  , indirection: 1\n  , get: function get (buf, offset) {\n      return buf['readInt32' + exports.endianness](offset || 0)\n    }\n  , set: function set (buf, offset, val) {\n      return buf['writeInt32' + exports.endianness](val, offset || 0)\n    }\n}\n\n/**\n * The `uint32` type.\n */\n\ntypes.uint32 = {\n    size: exports.sizeof.uint32\n  , indirection: 1\n  , get: function get (buf, offset) {\n      return buf['readUInt32' + exports.endianness](offset || 0)\n    }\n  , set: function set (buf, offset, val) {\n      return buf['writeUInt32' + exports.endianness](val, offset || 0)\n    }\n}\n\n/**\n * The `int64` type.\n */\n\ntypes.int64 = {\n    size: exports.sizeof.int64\n  , indirection: 1\n  , get: function get (buf, offset) {\n      return buf['readInt64' + exports.endianness](offset || 0)\n    }\n  , set: function set (buf, offset, val) {\n      return buf['writeInt64' + exports.endianness](val, offset || 0)\n    }\n}\n\n/**\n * The `uint64` type.\n */\n\ntypes.uint64 = {\n    size: exports.sizeof.uint64\n  , indirection: 1\n  , get: function get (buf, offset) {\n      return buf['readUInt64' + exports.endianness](offset || 0)\n    }\n  , set: function set (buf, offset, val) {\n      return buf['writeUInt64' + exports.endianness](val, offset || 0)\n    }\n}\n\n/**\n * The `float` type.\n */\n\ntypes.float = {\n    size: exports.sizeof.float\n  , indirection: 1\n  , get: function get (buf, offset) {\n      return buf['readFloat' + exports.endianness](offset || 0)\n    }\n  , set: function set (buf, offset, val) {\n      return buf['writeFloat' + exports.endianness](val, offset || 0)\n    }\n}\n\n/**\n * The `double` type.\n */\n\ntypes.double = {\n    size: exports.sizeof.double\n  , indirection: 1\n  , get: function get (buf, offset) {\n      return buf['readDouble' + exports.endianness](offset || 0)\n    }\n  , set: function set (buf, offset, val) {\n      return buf['writeDouble' + exports.endianness](val, offset || 0)\n    }\n}\n\n/**\n * The `Object` type. This can be used to read/write regular JS Objects\n * into raw memory.\n */\n\ntypes.Object = {\n    size: exports.sizeof.Object\n  , indirection: 1\n  , get: function get (buf, offset) {\n      return buf.readObject(offset || 0)\n    }\n  , set: function set (buf, offset, val) {\n      return buf.writeObject(val, offset || 0)\n    }\n}\n\n/**\n * The `CString` (a.k.a `\"string\"`) type.\n *\n * CStrings are a kind of weird thing. We say it's `sizeof(char *)`, and\n * `indirection` level of 1, which means that we have to return a Buffer that\n * is pointer sized, and points to a some utf8 string data, so we have to create\n * a 2nd \"in-between\" buffer.\n */\n\ntypes.CString = {\n    size: exports.sizeof.pointer\n  , alignment: exports.alignof.pointer\n  , indirection: 1\n  , get: function get (buf, offset) {\n      var _buf = exports.readPointer(buf, offset)\n      if (exports.isNull(_buf)) {\n        return null\n      }\n      return exports.readCString(_buf, 0)\n    }\n  , set: function set (buf, offset, val) {\n      var _buf\n      if (Buffer.isBuffer(val)) {\n        _buf = val\n      } else {\n        // assume string\n        _buf = exports.allocCString(val)\n      }\n      return exports.writePointer(buf, offset, _buf)\n    }\n}\n\n// alias Utf8String\nvar utfstringwarned = false\nObject.defineProperty(types, 'Utf8String', {\n    enumerable: false\n  , configurable: true\n  , get: function () {\n      if (!utfstringwarned) {\n        utfstringwarned = true\n        console.error('\"Utf8String\" type is deprecated, use \"CString\" instead')\n      }\n      return types.CString\n    }\n})\n\n/**\n * The `bool` type.\n *\n * Wrapper type around `types.uint8` that accepts/returns `true` or\n * `false` Boolean JavaScript values.\n *\n * @name bool\n *\n */\n\n/**\n * The `byte` type.\n *\n * @name byte\n */\n\n/**\n * The `char` type.\n *\n * @name char\n */\n\n/**\n * The `uchar` type.\n *\n * @name uchar\n */\n\n/**\n * The `short` type.\n *\n * @name short\n */\n\n/**\n * The `ushort` type.\n *\n * @name ushort\n */\n\n/**\n * The `int` type.\n *\n * @name int\n */\n\n/**\n * The `uint` type.\n *\n * @name uint\n */\n\n/**\n * The `long` type.\n *\n * @name long\n */\n\n/**\n * The `ulong` type.\n *\n * @name ulong\n */\n\n/**\n * The `longlong` type.\n *\n * @name longlong\n */\n\n/**\n * The `ulonglong` type.\n *\n * @name ulonglong\n */\n\n/**\n * The `size_t` type.\n *\n * @name size_t\n */\n\n// \"typedef\"s for the variable-sized types\n;[ 'bool', 'byte', 'char', 'uchar', 'short', 'ushort', 'int', 'uint', 'long'\n, 'ulong', 'longlong', 'ulonglong', 'size_t' ].forEach(function (name) {\n  var unsigned = name === 'bool'\n              || name === 'byte'\n              || name === 'size_t'\n              || name[0] === 'u'\n  var size = exports.sizeof[name]\n  assert(size >= 1 && size <= 8)\n  var typeName = 'int' + (size * 8)\n  if (unsigned) {\n    typeName = 'u' + typeName\n  }\n  var type = exports.types[typeName]\n  assert(type)\n  exports.types[name] = Object.create(type)\n})\n\n// set the \"alignment\" property on the built-in types\nObject.keys(exports.alignof).forEach(function (name) {\n  if (name === 'pointer') return\n  exports.types[name].alignment = exports.alignof[name]\n  assert(exports.types[name].alignment > 0)\n})\n\n// make the `bool` type work with JS true/false values\nexports.types.bool.get = (function (_get) {\n  return function get (buf, offset) {\n    return _get(buf, offset) ? true : false\n  }\n})(exports.types.bool.get)\nexports.types.bool.set = (function (_set) {\n  return function set (buf, offset, val) {\n    if (typeof val !== 'number') {\n      val = val ? 1 : 0\n    }\n    return _set(buf, offset, val)\n  }\n})(exports.types.bool.set)\n\n/*!\n * Set the `name` property of the types. Used for debugging...\n */\n\nObject.keys(exports.types).forEach(function (name) {\n  exports.types[name].name = name\n})\n\n/*!\n * This `char *` type is used by \"allocCString()\" above.\n */\n\nvar charPtrType = exports.refType(exports.types.char)\n\n/*!\n * Set the `type` property of the `NULL` pointer Buffer object.\n */\n\nexports.NULL.type = exports.types.void\n\n/**\n * `NULL_POINTER` is a pointer-sized `Buffer` instance pointing to `NULL`.\n * Conceptually, it's equivalent to the following C code:\n *\n * ``` c\n * char *null_pointer;\n * null_pointer = NULL;\n * ```\n *\n * @type Buffer\n */\n\nexports.NULL_POINTER = exports.ref(exports.NULL)\n\n/**\n * All these '...' comment blocks below are for the documentation generator.\n *\n * @section buffer\n */\n\nBuffer.prototype.address = function address () {\n  return exports.address(this, 0)\n}\n\n/**\n * ...\n */\n\nBuffer.prototype.hexAddress = function hexAddress () {\n  return exports.hexAddress(this, 0)\n}\n\n/**\n * ...\n */\n\nBuffer.prototype.isNull = function isNull () {\n  return exports.isNull(this, 0)\n}\n\n/**\n * ...\n */\n\nBuffer.prototype.ref = function ref () {\n  return exports.ref(this)\n}\n\n/**\n * ...\n */\n\nBuffer.prototype.deref = function deref () {\n  return exports.deref(this)\n}\n\n/**\n * ...\n */\n\nBuffer.prototype.readObject = function readObject (offset) {\n  return exports.readObject(this, offset)\n}\n\n/**\n * ...\n */\n\nBuffer.prototype.writeObject = function writeObject (obj, offset) {\n  return exports.writeObject(this, offset, obj)\n}\n\n/**\n * ...\n */\n\nBuffer.prototype.readPointer = function readPointer (offset, size) {\n  return exports.readPointer(this, offset, size)\n}\n\n/**\n * ...\n */\n\nBuffer.prototype.writePointer = function writePointer (ptr, offset) {\n  return exports.writePointer(this, offset, ptr)\n}\n\n/**\n * ...\n */\n\nBuffer.prototype.readCString = function readCString (offset) {\n  return exports.readCString(this, offset)\n}\n\n/**\n * ...\n */\n\nBuffer.prototype.writeCString = function writeCString (string, offset, encoding) {\n  return exports.writeCString(this, offset, string, encoding)\n}\n\n/**\n * ...\n */\n\nBuffer.prototype.readInt64BE = function readInt64BE (offset) {\n  return exports.readInt64BE(this, offset)\n}\n\n/**\n * ...\n */\n\nBuffer.prototype.writeInt64BE = function writeInt64BE (val, offset) {\n  return exports.writeInt64BE(this, offset, val)\n}\n\n/**\n * ...\n */\n\nBuffer.prototype.readUInt64BE = function readUInt64BE (offset) {\n  return exports.readUInt64BE(this, offset)\n}\n\n/**\n * ...\n */\n\nBuffer.prototype.writeUInt64BE = function writeUInt64BE (val, offset) {\n  return exports.writeUInt64BE(this, offset, val)\n}\n\n/**\n * ...\n */\n\nBuffer.prototype.readInt64LE = function readInt64LE (offset) {\n  return exports.readInt64LE(this, offset)\n}\n\n/**\n * ...\n */\n\nBuffer.prototype.writeInt64LE = function writeInt64LE (val, offset) {\n  return exports.writeInt64LE(this, offset, val)\n}\n\n/**\n * ...\n */\n\nBuffer.prototype.readUInt64LE = function readUInt64LE (offset) {\n  return exports.readUInt64LE(this, offset)\n}\n\n/**\n * ...\n */\n\nBuffer.prototype.writeUInt64LE = function writeUInt64LE (val, offset) {\n  return exports.writeUInt64LE(this, offset, val)\n}\n\n/**\n * ...\n */\n\nBuffer.prototype.reinterpret = function reinterpret (size, offset) {\n  return exports.reinterpret(this, size, offset)\n}\n\n/**\n * ...\n */\n\nBuffer.prototype.reinterpretUntilZeros = function reinterpretUntilZeros (size, offset) {\n  return exports.reinterpretUntilZeros(this, size, offset)\n}\n\n/**\n * `ref` overwrites the default `Buffer#inspect()` function to include the\n * hex-encoded memory address of the Buffer instance when invoked.\n *\n * This is simply a nice-to-have.\n *\n * **Before**:\n *\n * ``` js\n * console.log(new Buffer('ref'));\n * <Buffer 72 65 66>\n * ```\n *\n * **After**:\n *\n * ``` js\n * console.log(new Buffer('ref'));\n * <Buffer@0x103015490 72 65 66>\n * ```\n */\n\nBuffer.prototype.inspect = overwriteInspect(Buffer.prototype.inspect)\n\n// does SlowBuffer inherit from Buffer? (node >= v0.7.9)\nif (!(exports.NULL instanceof Buffer)) {\n  debug('extending SlowBuffer\\'s prototype since it doesn\\'t inherit from Buffer.prototype')\n\n  /*!\n   * SlowBuffer convenience methods.\n   */\n\n  var SlowBuffer = require('buffer').SlowBuffer\n\n  SlowBuffer.prototype.address = Buffer.prototype.address\n  SlowBuffer.prototype.hexAddress = Buffer.prototype.hexAddress\n  SlowBuffer.prototype.isNull = Buffer.prototype.isNull\n  SlowBuffer.prototype.ref = Buffer.prototype.ref\n  SlowBuffer.prototype.deref = Buffer.prototype.deref\n  SlowBuffer.prototype.readObject = Buffer.prototype.readObject\n  SlowBuffer.prototype.writeObject = Buffer.prototype.writeObject\n  SlowBuffer.prototype.readPointer = Buffer.prototype.readPointer\n  SlowBuffer.prototype.writePointer = Buffer.prototype.writePointer\n  SlowBuffer.prototype.readCString = Buffer.prototype.readCString\n  SlowBuffer.prototype.writeCString = Buffer.prototype.writeCString\n  SlowBuffer.prototype.reinterpret = Buffer.prototype.reinterpret\n  SlowBuffer.prototype.reinterpretUntilZeros = Buffer.prototype.reinterpretUntilZeros\n  SlowBuffer.prototype.readInt64BE = Buffer.prototype.readInt64BE\n  SlowBuffer.prototype.writeInt64BE = Buffer.prototype.writeInt64BE\n  SlowBuffer.prototype.readUInt64BE = Buffer.prototype.readUInt64BE\n  SlowBuffer.prototype.writeUInt64BE = Buffer.prototype.writeUInt64BE\n  SlowBuffer.prototype.readInt64LE = Buffer.prototype.readInt64LE\n  SlowBuffer.prototype.writeInt64LE = Buffer.prototype.writeInt64LE\n  SlowBuffer.prototype.readUInt64LE = Buffer.prototype.readUInt64LE\n  SlowBuffer.prototype.writeUInt64LE = Buffer.prototype.writeUInt64LE\n  SlowBuffer.prototype.inspect = overwriteInspect(SlowBuffer.prototype.inspect)\n}\n\nfunction overwriteInspect (inspect) {\n  if (inspect.name === 'refinspect') {\n    return inspect\n  } else {\n    return function refinspect () {\n      var v = inspect.apply(this, arguments)\n      return v.replace('Buffer', 'Buffer@0x' + this.hexAddress())\n    }\n  }\n}\n"]}