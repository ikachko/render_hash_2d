{"version":3,"sources":["../../../lib/ref-libs/struct.js"],"names":["ref","require","util","assert","debug","module","exports","Struct","StructType","arg","data","store","Buffer","isBuffer","length","size","type","key","_instanceCreated","prototype","Object","create","proto","constructor","value","enumerable","writable","configurable","defineProperty","toString","fields","opt","arguments","alignment","indirection","isPacked","packed","Boolean","get","set","Array","isArray","forEach","a","name","keys","buffer","offset","slice","isStruct","copy","coerceType","equal","test","field","cacheName","desc","got","recalc","struct","fieldNames","alignof","pointer","Math","min","max","fixedLength","addType","i","align","padding","sizeof","left","NULL","toObject","obj","k","toJSON","inspect"],"mappings":"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","file":"struct.js","sourcesContent":["\n/**\n * An interface for modeling and instantiating C-style data structures. This is\n * not a constructor per-say, but a constructor generator. It takes an array of\n * tuples, the left side being the type, and the right side being a field name.\n * The order should be the same order it would appear in the C-style struct\n * definition. It returns a function that can be used to construct an object that\n * reads and writes to the data structure using properties specified by the\n * initial field list.\n *\n * The only verboten field names are \"ref\", which is used used on struct\n * instances as a function to retrieve the backing Buffer instance of the\n * struct, and \"ref.buffer\" which contains the backing Buffer instance.\n *\n *\n * Example:\n *\n * ``` javascript\n * var ref = require('ref')\n * var Struct = require('ref-struct')\n *\n * // create the `char *` type\n * var charPtr = ref.refType(ref.types.char)\n * var int = ref.types.int\n *\n * // create the struct \"type\" / constructor\n * var PasswordEntry = Struct({\n *     'username': 'string'\n *   , 'password': 'string'\n *   , 'salt':     int\n * })\n *\n * // create an instance of the struct, backed a Buffer instance\n * var pwd = new PasswordEntry()\n * pwd.username = 'ricky'\n * pwd.password = 'rbransonlovesnode.js'\n * pwd.salt = (Math.random() * 1000000) | 0\n *\n * pwd.username // → 'ricky'\n * pwd.password // → 'rbransonlovesnode.js'\n * pwd.salt     // → 820088\n * ```\n */\n\n/**\n * Module dependencies.\n */\n\nvar ref = require('./ref')\nvar util = require('util')\nvar assert = require('assert')\nvar debug = require('debug')('ref:struct')\n\n/**\n * Module exports.\n */\n\nmodule.exports = Struct\n\n/**\n * The Struct \"type\" meta-constructor.\n */\n\nfunction Struct () {\n  debug('defining new struct \"type\"')\n\n  /**\n   * This is the \"constructor\" of the Struct type that gets returned.\n   *\n   * Invoke it with `new` to create a new Buffer instance backing the struct.\n   * Pass it an existing Buffer instance to use that as the backing buffer.\n   * Pass in an Object containing the struct fields to auto-populate the\n   * struct with the data.\n   */\n\n  function StructType (arg, data) {\n    if (!(this instanceof StructType)) {\n      return new StructType(arg, data)\n    }\n    debug('creating new struct instance')\n    var store\n    if (Buffer.isBuffer(arg)) {\n      debug('using passed-in Buffer instance to back the struct', arg)\n      assert(arg.length >= StructType.size, 'Buffer instance must be at least ' +\n          StructType.size + ' bytes to back this struct type')\n      store = arg\n      arg = data\n    } else {\n      debug('creating new Buffer instance to back the struct (size: %d)', StructType.size)\n      store = new Buffer(StructType.size)\n    }\n\n    // set the backing Buffer store\n    store.type = StructType\n    this['ref.buffer'] = store\n\n    if (arg) {\n      for (var key in arg) {\n        // hopefully hit the struct setters\n        this[key] = arg[key]\n      }\n    }\n    StructType._instanceCreated = true\n  }\n\n  // make instances inherit from the `proto`\n  StructType.prototype = Object.create(proto, {\n    constructor: {\n        value: StructType\n      , enumerable: false\n      , writable: true\n      , configurable: true\n    }\n  })\n\n  StructType.defineProperty = defineProperty\n  StructType.toString = toString\n  StructType.fields = {}\n\n  var opt = (arguments.length > 0 && arguments[1]) ? arguments[1] : {};\n  // Setup the ref \"type\" interface. The constructor doubles as the \"type\" object\n  StructType.size = 0\n  StructType.alignment = 0\n  StructType.indirection = 1\n  StructType.isPacked = opt.packed ? Boolean(opt.packed) : false\n  StructType.get = get\n  StructType.set = set\n\n  // Read the fields list and apply all the fields to the struct\n  // TODO: Better arg handling... (maybe look at ES6 binary data API?)\n  var arg = arguments[0]\n  if (Array.isArray(arg)) {\n    // legacy API\n    arg.forEach(function (a) {\n      var type = a[0]\n      var name = a[1]\n      StructType.defineProperty(name, type)\n    })\n  } else if (typeof arg === 'object') {\n    Object.keys(arg).forEach(function (name) {\n      var type = arg[name]\n      StructType.defineProperty(name, type)\n    })\n  }\n\n  return StructType\n}\n\n/**\n * The \"get\" function of the Struct \"type\" interface\n */\n\nfunction get (buffer, offset) {\n  debug('Struct \"type\" getter for buffer at offset', buffer, offset)\n  if (offset > 0) {\n    buffer = buffer.slice(offset)\n  }\n  return new this(buffer)\n}\n\n/**\n * The \"set\" function of the Struct \"type\" interface\n */\n\nfunction set (buffer, offset, value) {\n  debug('Struct \"type\" setter for buffer at offset', buffer, offset, value)\n  var isStruct = value instanceof this\n  if (isStruct) {\n    // optimization: copy the buffer contents directly rather\n    // than going through the ref-struct constructor\n    value['ref.buffer'].copy(buffer, offset, 0, this.size)\n  } else {\n    if (offset > 0) {\n      buffer = buffer.slice(offset)\n    }\n    new this(buffer, value)\n  }\n}\n\n/**\n * Custom `toString()` override for struct type instances.\n */\n\nfunction toString () {\n  return '[StructType]'\n}\n\n/**\n * Adds a new field to the struct instance with the given name and type.\n * Note that this function will throw an Error if any instances of the struct\n * type have already been created, therefore this function must be called at the\n * beginning, before any instances are created.\n */\n\nfunction defineProperty (name, type) {\n  debug('defining new struct type field', name)\n\n  // allow string types for convenience\n  type = ref.coerceType(type)\n\n  assert(!this._instanceCreated, 'an instance of this Struct type has already ' +\n      'been created, cannot add new \"fields\" anymore')\n  assert.equal('string', typeof name, 'expected a \"string\" field name')\n  assert(type && /object|function/i.test(typeof type) && 'size' in type &&\n      'indirection' in type\n      , 'expected a \"type\" object describing the field type: \"' + type + '\"')\n  assert(type.indirection > 1 || type.size > 0,\n      '\"type\" object must have a size greater than 0')\n  assert(!(name in this.prototype), 'the field \"' + name +\n      '\" already exists in this Struct type')\n\n  var field = {\n    type: type\n  }\n  this.fields[name] = field\n  var cacheName = '_cache' + name\n\n  // define the getter/setter property\n  var desc = { enumerable: true , configurable: true }\n  desc.get = function () {\n    if (this[cacheName]) {\n      return this[cacheName]\n    }\n    debug('getting \"%s\" struct field (offset: %d)', name, field.offset)\n    var got = ref.get(this['ref.buffer'], field.offset, type)\n    if (typeof got === 'object') {\n      this[cacheName] = got;\n    }\n    return got;\n  }\n  desc.set = function (value) {\n    this[cacheName] = null\n    debug('setting \"%s\" struct field (offset: %d)', name, field.offset, value)\n    return ref.set(this['ref.buffer'], field.offset, value, type)\n  }\n\n  // calculate the new size and field offsets\n  recalc(this)\n\n  Object.defineProperty(this.prototype, name, desc)\n}\n\nfunction recalc (struct) {\n\n  // reset size and alignment\n  struct.size = 0\n  struct.alignment = 0\n\n  var fieldNames = Object.keys(struct.fields)\n\n  // first loop through is to determine the `alignment` of this struct\n  fieldNames.forEach(function (name) {\n    var field = struct.fields[name]\n    var type = field.type\n    var alignment = type.alignment || ref.alignof.pointer\n    if (type.indirection > 1) {\n      alignment = ref.alignof.pointer\n    }\n    if (struct.isPacked) {\n      struct.alignment = Math.min(struct.alignment || alignment, alignment)\n    } else {\n      struct.alignment = Math.max(struct.alignment, alignment)\n    }\n  })\n\n  // second loop through sets the `offset` property on each \"field\"\n  // object, and sets the `struct.size` as we go along\n  fieldNames.forEach(function (name) {\n    var field = struct.fields[name]\n    var type = field.type\n\n    if (null != type.fixedLength) {\n      // \"ref-array\" types set the \"fixedLength\" prop. don't treat arrays like one\n      // contiguous entity. instead, treat them like individual elements in the\n      // struct. doing this makes the padding end up being calculated correctly.\n      field.offset = addType(type.type)\n      for (var i = 1; i < type.fixedLength; i++) {\n        addType(type.type)\n      }\n    } else {\n      field.offset = addType(type)\n    }\n  })\n\n  function addType (type) {\n    var offset = struct.size\n    var align = type.indirection === 1 ? type.alignment : ref.alignof.pointer\n    var padding = struct.isPacked ? 0 : (align - (offset % align)) % align\n    var size = type.indirection === 1 ? type.size : ref.sizeof.pointer\n\n    offset += padding\n\n    if (!struct.isPacked) {\n      assert.equal(offset % align, 0, \"offset should align\")\n    }\n\n    // adjust the \"size\" of the struct type\n    struct.size = offset + size\n\n    // return the calulated offset\n    return offset\n  }\n\n  // any final padding?\n  var left = struct.size % struct.alignment\n  if (left > 0) {\n    debug('additional padding to the end of struct:', struct.alignment - left)\n    struct.size += struct.alignment - left\n  }\n}\n\n/**\n * this is the custom prototype of Struct type instances.\n */\n\nvar proto = {}\n\n/**\n * set a placeholder variable on the prototype so that defineProperty() will\n * throw an error if you try to define a struct field with the name \"buffer\".\n */\n\nproto['ref.buffer'] = ref.NULL\n\n/**\n * Flattens the Struct instance into a regular JavaScript Object. This function\n * \"gets\" all the defined properties.\n *\n * @api public\n */\n\nproto.toObject = function toObject () {\n  var obj = {}\n  Object.keys(this.constructor.fields).forEach(function (k) {\n    obj[k] = this[k]\n  }, this)\n  return obj\n}\n\n/**\n * Basic `JSON.stringify(struct)` support.\n */\n\nproto.toJSON = function toJSON () {\n  return this.toObject()\n}\n\n/**\n * `.inspect()` override. For the REPL.\n *\n * @api public\n */\n\nproto.inspect = function inspect () {\n  var obj = this.toObject()\n  // add instance's \"own properties\"\n  Object.keys(this).forEach(function (k) {\n    obj[k] = this[k]\n  }, this)\n  return util.inspect(obj)\n}\n\n/**\n * returns a Buffer pointing to this struct data structure.\n */\n\nproto.ref = function ref () {\n  return this['ref.buffer']\n}\n"]}