{"version":3,"sources":["../../../lib/ref-libs/array.js"],"names":["_ref","require","assert","debug","ArrayIndex","isArray","Array","module","exports","_type","_length","type","coerceType","fixedLength","ArrayType","data","length","call","item_size","BYTES_PER_ELEMENT","arguments","buffer","Buffer","Error","len","i","set","isBuffer","expectedLength","slice","prototype","Object","create","constructor","value","enumerable","writable","configurable","NULL","ref","get","getter","setter","lengthChanged","indirection","size","sizeof","pointer","alignment","alignof","getRef","setRef","untilZeros","offset","array","isInstance","readPointer","ptr","writePointer","origSize","r","types","CString","buf","index","baseType","end","reinterpret","newLength","isNull","start","reinterpretUntilZeros"],"mappings":"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","file":"array.js","sourcesContent":["\n/**\n * Module dependencies.\n */\n\nvar _ref = require('./ref')\nvar assert = require('assert')\nvar debug = require('debug')('ref:array')\nvar ArrayIndex = require('./ArrayIndex')\nvar isArray = Array.isArray\n\n/**\n * The Array \"type\" constructor.\n * The returned constructor's API is highly influenced by the WebGL\n * TypedArray API.\n */\n\nmodule.exports = function Array (_type, _length) {\n  debug('defining new array \"type\"')\n  var type = _ref.coerceType(_type)\n  var fixedLength = _length | 0\n\n  /**\n   * This is the ArrayType \"constructor\" that gets returned.\n   */\n\n  function ArrayType (data, length) {\n    if (!(this instanceof ArrayType)) {\n      return new ArrayType(data, length)\n    }\n    debug('creating new array instance')\n    ArrayIndex.call(this)\n    var item_size = ArrayType.BYTES_PER_ELEMENT\n    if (0 === arguments.length) {\n      // new IntArray()\n      // use the \"fixedLength\" if provided, otherwise throw an Error\n      if (fixedLength > 0) {\n        this.length = fixedLength\n        this.buffer = new Buffer(this.length * item_size)\n      } else {\n        throw new Error('A \"length\", \"array\" or \"buffer\" must be passed as the first argument')\n      }\n    } else if ('number' == typeof data) {\n      // new IntArray(69)\n      this.length = data\n      this.buffer = new Buffer(this.length * item_size)\n    } else if (isArray(data)) {\n      // new IntArray([ 1, 2, 3, 4, 5 ], {len})\n      // use optional \"length\" if provided, otherwise use \"fixedLength, otherwise\n      // use the Array's .length\n      var len = 0\n      if (null != length) {\n        len = length\n      } else if (fixedLength > 0) {\n        len = fixedLength\n      } else {\n        len = data.length\n      }\n      if (data.length < len) {\n        throw new Error('array length must be at least ' + len + ', got ' + data.length)\n      }\n      this.length = len\n      this.buffer = new Buffer(len * item_size)\n      for (var i = 0; i < len; i++) {\n        this[ArrayIndex.set](i, data[i])\n      }\n    } else if (Buffer.isBuffer(data)) {\n      // new IntArray(Buffer(8))\n      var len = 0\n      if (null != length) {\n        len = length\n      } else if (fixedLength > 0) {\n        len = fixedLength\n      } else {\n        len = data.length / item_size | 0\n      }\n      var expectedLength = item_size * len\n      this.length = len\n      if (data.length != expectedLength) {\n        if (data.length < expectedLength) {\n          throw new Error('buffer length must be at least ' + expectedLength + ', got ' + data.length)\n        } else {\n          debug('resizing buffer from %d to %d', data.length, expectedLength)\n          data = data.slice(0, expectedLength)\n        }\n      }\n      this.buffer = data\n    }\n  }\n\n  // make array instances inherit from our `ArrayIndex.prototype`\n  ArrayType.prototype = Object.create(ArrayIndex.prototype, {\n    constructor: {\n      value: ArrayType,\n      enumerable: false,\n      writable: true,\n      configurable: true\n    },\n    // \"buffer\" is the backing buffer instance\n    buffer: {\n      value: _ref.NULL,\n      enumerable: true,\n      writable: true,\n      configurable: true\n    },\n    // \"node-ffi\" calls this when passed an array instance to an ffi'd function\n    ref: {\n      value: ref,\n      enumerable: true,\n      writable: true,\n      configurable: true\n    },\n    // \"slice\" implementation\n    slice: {\n      value: slice,\n      enumerable: true,\n      writable: true,\n      configurable: true\n    }\n  })\n\n  // part of the \"array-index\" interface\n  ArrayType.prototype[ArrayIndex.get] = getter\n  ArrayType.prototype[ArrayIndex.set] = setter\n  ArrayType.prototype[ArrayIndex.lengthChanged] = lengthChanged\n\n  // save down the \"fixedLength\" if specified. \"ref-struct\" needs this value\n  if (fixedLength > 0) {\n    ArrayType.fixedLength = fixedLength\n  }\n\n  // keep a reference to the base \"type\"\n  ArrayType.type = type\n  ArrayType.BYTES_PER_ELEMENT = type.indirection == 1 ? type.size : _ref.sizeof.pointer\n  assert(ArrayType.BYTES_PER_ELEMENT > 0)\n\n  // the ref \"type\" interface\n  if (fixedLength > 0) {\n    // this \"type\" is probably going in a ref-struct or being used manually\n    ArrayType.size = ArrayType.BYTES_PER_ELEMENT * fixedLength\n    ArrayType.alignment = type.alignment\n    ArrayType.indirection = 1\n    ArrayType.get = get\n    ArrayType.set = set\n  } else {\n    // this \"type\" is probably an argument/return value for a node-ffi function\n    ArrayType.size = _ref.sizeof.pointer\n    ArrayType.alignment = _ref.alignof.pointer\n    ArrayType.indirection = 1\n    ArrayType.get = getRef\n    ArrayType.set = setRef\n  }\n\n  // untilZeros() function\n  ArrayType.untilZeros = untilZeros\n\n  return ArrayType\n}\n\n/**\n * The \"get\" function of the Array \"type\" interface.\n * Most likely invoked when accessing within a \"ref-struct\" type.\n */\n\nfunction get (buffer, offset) {\n  debug('Array \"type\" getter for buffer at offset', offset)\n  if (offset > 0) {\n    buffer = buffer.slice(offset)\n  }\n  return new this(buffer)\n}\n\n/**\n * The \"set\" function of the Array \"type\" interface.\n * Most likely invoked when setting within a \"ref-struct\" type.\n */\n\nfunction set (buffer, offset, value) {\n  debug('Array \"type\" setter for buffer at offset', buffer, offset, value)\n  var array = this.get(buffer, offset)\n  var isInstance = value instanceof this\n  if (isInstance) {\n    for (var i = 0; i < value.length; i++) {\n      array[ArrayIndex.set](i, value[ArrayIndex.get](i));\n    }\n  } else if (isArray(value)) {\n    for (var i = 0; i < value.length; i++) {\n      array[ArrayIndex.set](i, value[i]);\n    }\n  } else {\n    throw new Error('not sure how to set into Array: ' + value)\n  }\n}\n\n/**\n * Reads a pointer from the given offset and returns a new \"array\" instance of\n * this type.\n * Most likely invoked when getting an array instance back as a return value from\n * an FFI'd function.\n */\n\nfunction getRef (buffer, offset) {\n  debug('Array reference \"type\" getter for buffer at offset', offset)\n  return new this(buffer.readPointer(offset))\n}\n\n/**\n * Most likely invoked when passing an array instance as an argument to an FFI'd\n * function.\n */\n\nfunction setRef (buffer, offset, value) {\n  debug('Array reference \"type\" setter for buffer at offset', offset)\n  var ptr\n  if (value instanceof this) {\n    ptr = value.buffer\n  } else {\n    ptr = new this(value).buffer\n  }\n  _ref.writePointer(buffer, offset, ptr)\n}\n\n/**\n * Returns a reference to the backing buffer of this Array instance.\n *\n * i.e. if the array represents `int[]` (a.k.a. `int *`),\n *      then the returned Buffer represents `int (*)[]` (a.k.a. `int **`)\n */\n\nfunction ref () {\n  debug('ref()')\n  var type = this.constructor\n  var origSize = this.buffer.length\n  var r = _ref.ref(this.buffer)\n  r.type = Object.create(_ref.types.CString)\n  r.type.get = function (buf, offset) {\n    return new type(_ref.readPointer(buf, offset | 0, origSize))\n  }\n  r.type.set = function () {\n    assert(0, 'implement!!!')\n  }\n  return r\n}\n\n/**\n * The \"getter\" implementation for the \"array-index\" interface.\n */\n\nfunction getter (index) {\n  debug('getting array[%d]', index)\n  var size = this.constructor.BYTES_PER_ELEMENT\n  var baseType = this.constructor.type\n  var offset = size * index\n  var end = offset + size\n  var buffer = this.buffer\n  if (buffer.length < end) {\n    debug('reinterpreting buffer from %d to %d', buffer.length, end)\n    buffer = _ref.reinterpret(buffer, end)\n    this._length = end / size\n  }\n  return _ref.get(buffer, offset, baseType)\n}\n\n/**\n * The \"setter\" implementation for  the \"array-index\" interface.\n */\n\nfunction setter (index, value) {\n  debug('setting array[%d]', index)\n  var size = this.constructor.BYTES_PER_ELEMENT\n  var baseType = this.constructor.type\n  var offset = size * index\n  var end = offset + size\n  var buffer = this.buffer\n  if (buffer.length < end) {\n    debug('reinterpreting buffer from %d to %d', buffer.length, end)\n    buffer = _ref.reinterpret(buffer, end)\n  }\n  // TODO: DRY with getter()\n\n  _ref.set(buffer, offset, value, baseType)\n  return value\n}\n\nfunction lengthChanged (newLength) {\n  if (this.buffer && !_ref.isNull(this.buffer) && this.buffer.length < newLength) {\n    debug('reinterpreting buffer from %d to %d', this.buffer.length, newLength)\n    this.buffer = _ref.reinterpret(this.buffer, newLength)\n  }\n}\n\n/**\n * The \"slice\" implementation.\n */\n\nfunction slice (start, end) {\n  var data\n\n  if (end) {\n    debug('slicing array from %d to %d', start, end)\n    data = this.buffer.slice(start*this.constructor.BYTES_PER_ELEMENT, end*this.constructor.BYTES_PER_ELEMENT)\n  } else {\n    debug('slicing array from %d', start)\n    data = this.buffer.slice(start*this.constructor.BYTES_PER_ELEMENT)\n  }\n\n  return new this.constructor(data)\n}\n\n/**\n * Accepts a Buffer instance that should be an already-populated with data for the\n * ArrayType. The \"length\" of the Array is determined by searching through the\n * buffer's contents until an aligned NULL pointer is encountered.\n *\n * @param {Buffer} buffer the null-terminated buffer to convert into an Array\n * @api public\n */\n\nfunction untilZeros (buffer) {\n  return new this(_ref.reinterpretUntilZeros(buffer, this.type.size))\n}\n"]}