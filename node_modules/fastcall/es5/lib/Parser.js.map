{"version":3,"sources":["../../lib/Parser.js"],"names":["_","require","assert","verify","a","ert","ref","util","rex","typeCode","FunctionParser","RefTypeParser","MultilineParser","refHelpers","Parser","library","functionParser","refTypeParser","multilineParser","def","parse","typeHint","str","callMode","args","title","trim","pos","lastIndexOf","length","part1","substr","part2","defaultName","name","type","_makeRef","isInterface","value","isInteface","undefined","isString","callback","callbacks","code","match","matchType","structs","unions","arrays","_makeTypeWithLength","starCount","_countStars","stars","i","refType","indirection","isArrayType","getForType","propertyName","coerceType","_ensureRegistered","rootType","derefType","regBy","isStructType","isUnionType","makeName","defObj","isObject","result","each","key","_resolveStringType","findRefDeclaration","count","ch","module","exports"],"mappings":"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","file":"Parser.js","sourcesContent":["/*\nCopyright 2016 Gábor Mező (gabor.mezo@outlook.com)\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\n\n'use strict';\nconst _ = require('lodash');\nconst assert = require('assert');\nconst verify = require('./verify');\nconst a = verify.a;\nconst ert = verify.ert;\nconst ref = require('./ref-libs/ref');\nconst util = require('util');\nconst rex = require('./rex');\nconst typeCode = require('./typeCode');\nconst FunctionParser = require('./FunctionParser');\nconst RefTypeParser = require('./RefTypeParser');\nconst MultilineParser = require('./MultilineParser');\nconst refHelpers = require('./refHelpers');\n\nclass Parser {\n    constructor(library) {\n        a&&ert(library);\n\n        this.library = library;\n        this.functionParser = new FunctionParser(this);\n        this.refTypeParser = new RefTypeParser(this);\n        this.multilineParser = new MultilineParser(this);\n    }\n\n    parseFunction(def) {\n        return this.functionParser.parse(def);\n    }\n\n    parseRefType(def, typeHint) {\n        return this.refTypeParser.parse(def, typeHint);\n    }\n\n    parseMultiline(str, callMode) {\n        return this.multilineParser.parse(str, callMode);\n    }\n\n    _parseDeclaration(args) {\n        let def = args.def;\n        const title = args.title;\n        def = def.trim();\n        assert(def, `Invalid ${ title }: ${ def }`);\n        let pos = _.lastIndexOf(def, '*');\n        if (pos === -1) {\n            pos = _.lastIndexOf(def, ' ');\n        }\n        if (pos === -1) {\n            pos = def.length - 1;\n        }\n        let part1 = def.substr(0, pos + 1).trim();\n        let part2 = def.substr(pos + 1).trim();\n        if (!part1 && part2) {\n            part1 = part2;\n            part2 = null;\n        }\n        assert(part1, `Invalid ${ title }: ${ def }`);\n        if (!part2 && !args.defaultName) {\n            assert(false, `${ title } declaration's name expected.`);\n        }\n        return {\n            name: part2 || args.defaultName,\n            type: this._makeRef(part1, args.isInterface)\n        };\n    }\n\n    _makeRef(value, isInteface) {\n        if (isInteface === undefined) {\n            isInteface = true;\n        }\n        if (_.isString(value)) {\n            const callback = this.library.callbacks[value];\n            if (callback) {\n                a&&ert(callback.type.code);\n                a&&ert(callback.type.callback === callback);\n                return callback.type;\n            }\n            const match = rex.matchType(value);\n            if (match) {\n                const name = match.name;\n                const def = this.library.structs[name] || \n                    this.library.unions[name] ||\n                    this.library.arrays[name];\n                if (def) {\n                    let type = def.type;\n                    if (match.length) {\n                        type = def._makeTypeWithLength(match.length);\n                    }\n                    const starCount = Parser._countStars(match.stars);\n                    for (let i = 0; i < starCount; i++) {\n                        type = ref.refType(type);\n                    }\n                    if (isInteface) {\n                        assert(\n                            type.indirection > 1 || refHelpers.isArrayType(type), \n                            'Using struct or unions by value on function interfaces is not supported.');\n                    }\n                    if (starCount) {\n                        if (type.code === undefined) {\n                            type.code = typeCode.getForType(type);\n                        }\n                        if (type[def.propertyName] === undefined) {\n                            type[def.propertyName] = def;\n                        }\n                    }\n                    return type;\n                }\n            }\n        }\n        const type = ref.coerceType(value);\n        if (type.code === undefined) {\n            type.code = typeCode.getForType(type);\n        }\n        this._ensureRegistered(type);\n        return type;\n    }\n\n    _ensureRegistered(type) {\n        let rootType = type;\n        while (rootType.indirection > 1 || refHelpers.isArrayType(rootType)) {\n            if (rootType.indirection > 1) {\n                rootType = ref.derefType(rootType);\n            }\n            else {\n                rootType = rootType.type;\n            }\n        }\n        let regBy = null;\n        if (refHelpers.isStructType(rootType)) {\n            regBy = 'struct';\n        }\n        else if (refHelpers.isUnionType(rootType)) {\n            regBy = 'union';\n        }\n        else if (refHelpers.isArrayType(rootType)) {\n            regBy = 'array';\n        }\n\n        if (!regBy) {\n            return;\n        }\n\n        this.library[regBy]({ [this.library.makeName(rootType.name)]: rootType });\n    }\n\n    _resolveStringTypes(defObj) {\n        a&&ert(_.isObject(defObj));\n\n        const result = {};\n        _.each(defObj, (value, key) => {\n            let type = defObj[key];\n            if (_.isString(type)) {\n                type = this._resolveStringType(type);\n            }\n            result[key] = type;\n        });\n        return result;\n    }\n\n    _resolveStringType(type) {\n        a&&ert(_.isString(type));\n\n        let match = rex.matchType(type);\n        if (match) {\n            type = match.name;\n            let def = this.library.findRefDeclaration(type);\n            if (def) {\n                type = def.type;\n                if (match.length) {\n                    type = def._makeTypeWithLength(match.length);\n                }\n            }\n        }\n        const starCount = Parser._countStars(match.stars);\n        for (let i = 0; i < starCount; i++) {\n            type = ref.refType(type);\n        }\n        return type;\n    }\n\n    static _countStars(str) {\n        let count = 0;\n        for (let ch of str) {\n            if (ch === '*') {\n                ++count;\n            }\n        }\n        return count;\n    }\n}\n\nmodule.exports = Parser;"]}